#Building a subscriber
class MyNode : public rclcpp::Node {
private:
    // Declare subscriber as member variable
    rclcpp::Subscription<sensor_msgs::msg::PointCloud2>::SharedPtr lidar_subscriber_;
    
    // Callback function
    void lidarCallback(const sensor_msgs::msg::PointCloud2::SharedPtr msg) {
        // Process the point cloud data
        RCLCPP_INFO(this->get_logger(), "Received point cloud with %d points", 
            msg->width * msg->height);
    }

public:
    MyNode() : Node("my_node") {
        // Create subscriber in constructor
        lidar_subscriber_ = this->create_subscription<sensor_msgs::msg::PointCloud2>(
            "/lidar/points",  // topic name
            10,              // QoS history depth
            std::bind(&MyNode::lidarCallback, this, std::placeholders::_1)
        );
    }
};

===============================================================================================

#Building a publisher

class PublisherNode : public rclcpp::Node {
private:
    rclcpp::Publisher<std_msgs::msg::String>::SharedPtr publisher_;
    rclcpp::TimerBase::SharedPtr timer_;
    
    void timerCallback() {
        auto message = std_msgs::msg::String();
        message.data = "Timer triggered message";
        publisher_->publish(message);
    }
    
public:
    PublisherNode() : Node("publisher_node") {
        // Create publisher
        publisher_ = this->create_publisher<std_msgs::msg::String>("topic", 10);
        
        // Create timer that publishes every second
        timer_ = this->create_wall_timer(
            std::chrono::seconds(1),
            std::bind(&PublisherNode::timerCallback, this)
        );
    }
};
===============================================================================================

#Building a timer
class MyNode : public rclcpp::Node {
private:
    rclcpp::TimerBase::SharedPtr timer_;

public:
    MyNode() : Node("my_node") {
        timer_ = this->create_wall_timer(std::chrono::seconds(1), 
            std::bind(&MyNode::timerCallback, this));
    }
};

===============================================================================================

#What if I used pointer instead of shared_ptr?
1. The ROS 2 middleware expects shared pointers
2. shared_ptr is a smart pointer that manages the memory of an object through a pointer
   so it avoids memory leaks and double frees
3. Allows reference counting
   e.g.    
   std::shared_ptr<int> ptr1(new int(42));
   std::shared_ptr<int> ptr2 = ptr1;  
   ptr1.use_count();  // Returns 2
4. Thread safety
   // Thread safe across multiple threads
   void thread1(std::shared_ptr<Data> data) { ... }
   void thread2(std::shared_ptr<Data> data) { ... }